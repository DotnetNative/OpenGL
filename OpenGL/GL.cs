using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;

namespace OpenGL;
public unsafe static class GL
{
    public static GLInterface Interface { get; private set; }
    static GL()
    {
        Interface = new GLInterface();
    }

    public static void Accum(Enums.Op op, float value) => Interface.glAccum(op, value);
    public static void AlphaFunc(Enums.Func func, float @ref) => Interface.glAlphaFunc(func, @ref);
    public static byte AreTexturesResident(int n, uint[] textures, byte[] residences) => Interface.glAreTexturesResident(n, textures.Ptr(), residences.Ptr());
    public static void ArrayElement(int i) => Interface.glArrayElement(i);
    public static void Begin(Enums.Mode mode) => Interface.glBegin(mode);
    public static void BindTexture(Enums.TexPTarget target, uint texture) => Interface.glBindTexture(target, texture);
    public static void Bitmap(int width, int height, float xorig, float yorig, float xmove, float ymove, byte[] bitmap) => Interface.glBitmap(width, height, xorig, yorig, xmove, ymove, bitmap.Ptr());
    public static void BlendFunc(Enums.Factor sfactor, Enums.Factor dfactor) => Interface.glBlendFunc(sfactor, dfactor);
    public static void CallList(uint list) => Interface.glCallList(list);
    public static void CallLists(int n, Enums.Type type, void* lists) => Interface.glCallLists(n, type, lists);
    public static void Clear(uint mask) => Interface.glClear(mask);
    public static void ClearAccum(float red, float green, float blue, float alpha) => Interface.glClearAccum(red, green, blue, alpha);
    public static void ClearColor(float red, float green, float blue, float alpha) => Interface.glClearColor(red, green, blue, alpha);
    public static void ClearDepth(double depth) => Interface.glClearDepth(depth);
    public static void ClearIndex(float c) => Interface.glClearIndex(c);
    public static void ClearStencil(int s) => Interface.glClearStencil(s);
    public static void ClipPlane(Enums.Plane plane, double[] equation) => Interface.glClipPlane(plane, equation.Ptr());
    public static void Color3b(sbyte red, sbyte green, sbyte blue) => Interface.glColor3b(red, green, blue);
    public static void Color3bv(sbyte[] v) => Interface.glColor3bv(v.Ptr());
    public static void Color3d(double red, double green, double blue) => Interface.glColor3d(red, green, blue);
    public static void Color3dv(double[] v) => Interface.glColor3dv(v.Ptr());
    public static void Color3f(float red, float green, float blue) => Interface.glColor3f(red, green, blue);
    public static void Color3fv(float[] v) => Interface.glColor3fv(v.Ptr());
    public static void Color3i(int red, int green, int blue) => Interface.glColor3i(red, green, blue);
    public static void Color3iv(int[] v) => Interface.glColor3iv(v.Ptr());
    public static void Color3s(short red, short green, short blue) => Interface.glColor3s(red, green, blue);
    public static void Color3sv(short[] v) => Interface.glColor3sv(v.Ptr());
    public static void Color3ub(byte red, byte green, byte blue) => Interface.glColor3ub(red, green, blue);
    public static void Color3ubv(byte[] v) => Interface.glColor3ubv(v.Ptr());
    public static void Color3ui(uint red, uint green, uint blue) => Interface.glColor3ui(red, green, blue);
    public static void Color3uiv(uint[] v) => Interface.glColor3uiv(v.Ptr());
    public static void Color3us(ushort red, ushort green, ushort blue) => Interface.glColor3us(red, green, blue);
    public static void Color3usv(ushort[] v) => Interface.glColor3usv(v.Ptr());
    public static void Color4b(sbyte red, sbyte green, sbyte blue, sbyte alpha) => Interface.glColor4b(red, green, blue, alpha);
    public static void Color4bv(sbyte[] v) => Interface.glColor4bv(v.Ptr());
    public static void Color4d(double red, double green, double blue, double alpha) => Interface.glColor4d(red, green, blue, alpha);
    public static void Color4dv(double[] v) => Interface.glColor4dv(v.Ptr());
    public static void Color4f(float red, float green, float blue, float alpha) => Interface.glColor4f(red, green, blue, alpha);
    public static void Color4fv(float[] v) => Interface.glColor4fv(v.Ptr());
    public static void Color4i(int red, int green, int blue, int alpha) => Interface.glColor4i(red, green, blue, alpha);
    public static void Color4iv(int[] v) => Interface.glColor4iv(v.Ptr());
    public static void Color4s(short red, short green, short blue, short alpha) => Interface.glColor4s(red, green, blue, alpha);
    public static void Color4sv(short[] v) => Interface.glColor4sv(v.Ptr());
    public static void Color4ub(byte red, byte green, byte blue, byte alpha) => Interface.glColor4ub(red, green, blue, alpha);
    public static void Color4ubv(byte[] v) => Interface.glColor4ubv(v.Ptr());
    public static void Color4ui(uint red, uint green, uint blue, uint alpha) => Interface.glColor4ui(red, green, blue, alpha);
    public static void Color4uiv(uint[] v) => Interface.glColor4uiv(v.Ptr());
    public static void Color4us(ushort red, ushort green, ushort blue, ushort alpha) => Interface.glColor4us(red, green, blue, alpha);
    public static void Color4usv(ushort[] v) => Interface.glColor4usv(v.Ptr());
    public static void ColorMask(byte red, byte green, byte blue, byte alpha) => Interface.glColorMask(red, green, blue, alpha);
    public static void ColorMaterial(Enums.Face face, Enums.MaterialParam mode) => Interface.glColorMaterial(face, mode);
    public static void ColorPointer(int size, Enums.BType type, int stride, void* pointer) => Interface.glColorPointer(size, type, stride, pointer);
    public static void CopyPixels(int x, int y, int width, int height, Enums.CopyType type) => Interface.glCopyPixels(x, y, width, height, type);
    public static void CopyTexImage1D(Enums.TexPTarget target, int level, Enums.InternalFormat internalFormat, int x, int y, int width, int border) => Interface.glCopyTexImage1D(target, level, internalFormat, x, y, width, border);
    public static void CopyTexImage2D(Enums.TexPTarget target, int level, Enums.InternalFormat internalFormat, int x, int y, int width, int height, int border) => Interface.glCopyTexImage2D(target, level, internalFormat, x, y, width, height, border);
    public static void CopyTexSubImage1D(Enums.TexPTarget target, int level, int xoffset, int x, int y, int width) => Interface.glCopyTexSubImage1D(target, level, xoffset, x, y, width);
    public static void CopyTexSubImage2D(Enums.TexPTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height) => Interface.glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
    public static void CullFace(Enums.Face mode) => Interface.glCullFace(mode);
    public static void DeleteLists(uint list, int range) => Interface.glDeleteLists(list, range);
    public static void DeleteTextures(int n, uint[] textures) => Interface.glDeleteTextures(n, textures.Ptr());
    public static void DepthFunc(Enums.Func func) => Interface.glDepthFunc(func);
    public static void DepthMask(byte flag) => Interface.glDepthMask(flag);
    public static void DepthRange(double zNear, double zFar) => Interface.glDepthRange(zNear, zFar);
    public static void Disable(Enums.Cap cap) => Interface.glDisable(cap);
    public static void DisableClientState(Enums.ArrayState array) => Interface.glDisableClientState(array);
    public static void DrawArrays(Enums.Mode mode, int first, int count) => Interface.glDrawArrays(mode, first, count);
    public static void DrawBuffer(Enums.Mode mode) => Interface.glDrawBuffer(mode);
    public static void DrawElements(Enums.Mode mode, int count, Enums.BUType type, void* indices) => Interface.glDrawElements(mode, count, type, indices);
    public static void DrawPixels(int width, int height, Enums.ImageFormat format, Enums.BType type, void* pixels) => Interface.glDrawPixels(width, height, format, type, pixels);
    public static void EdgeFlag(byte flag) => Interface.glEdgeFlag(flag);
    public static void EdgeFlagPointer(int stride, void* pointer) => Interface.glEdgeFlagPointer(stride, pointer);
    public static void EdgeFlagv(byte[] flag) => Interface.glEdgeFlagv(flag.Ptr());
    public static void Enable(Enums.Cap cap) => Interface.glEnable(cap);
    public static void EnableClientState(Enums.ArrayState array) => Interface.glEnableClientState(array);
    public static void End() => Interface.glEnd();
    public static void EndList() => Interface.glEndList();
    public static void EvalCoord1d(double u) => Interface.glEvalCoord1d(u);
    public static void EvalCoord1dv(double[] u) => Interface.glEvalCoord1dv(u.Ptr());
    public static void EvalCoord1f(float u) => Interface.glEvalCoord1f(u);
    public static void EvalCoord1fv(float[] u) => Interface.glEvalCoord1fv(u.Ptr());
    public static void EvalCoord2d(double u, double v) => Interface.glEvalCoord2d(u, v);
    public static void EvalCoord2dv(double[] u) => Interface.glEvalCoord2dv(u.Ptr());
    public static void EvalCoord2f(float u, float v) => Interface.glEvalCoord2f(u, v);
    public static void EvalCoord2fv(float[] u) => Interface.glEvalCoord2fv(u.Ptr());
    public static void EvalMesh1(Enums.EMesh mode, int i1, int i2) => Interface.glEvalMesh1(mode, i1, i2);
    public static void EvalMesh2(Enums.Mesh mode, int i1, int i2, int j1, int j2) => Interface.glEvalMesh2(mode, i1, i2, j1, j2);
    public static void EvalPoint1(int i) => Interface.glEvalPoint1(i);
    public static void EvalPoint2(int i, int j) => Interface.glEvalPoint2(i, j);
    public static void FeedbackBuffer(int size, Enums.Vertex type, float[] buffer) => Interface.glFeedbackBuffer(size, type, buffer.Ptr());
    public static void Finish() => Interface.glFinish();
    public static void Flush() => Interface.glFlush();
    public static void Fogf(Enums.Fog pname, float param) => Interface.glFogf(pname, param);
    public static void Fogfv(Enums.Fog pname, float[] @params) => Interface.glFogfv(pname, @params.Ptr());
    public static void Fogi(Enums.Fog pname, int param) => Interface.glFogi(pname, param);
    public static void Fogiv(Enums.Fog pname, int[] @params) => Interface.glFogiv(pname, @params.Ptr());
    public static void FrontFace(Enums.FaceMode mode) => Interface.glFrontFace(mode);
    public static void Frustum(double left, double right, double bottom, double top, double zNear, double zFar) => Interface.glFrustum(left, right, bottom, top, zNear, zFar);
    public static uint GenLists(int range) => Interface.glGenLists(range);
    public static void GenTextures(int n, uint[] textures) => Interface.glGenTextures(n, textures.Ptr());
    public static void GetBooleanv(Enums.PName pname, byte[] @params) => Interface.glGetBooleanv(pname, @params.Ptr());
    public static void GetClipPlane(Enums.Plane plane, double[] equation) => Interface.glGetClipPlane(plane, equation.Ptr());
    public static void GetDoublev(Enums.PName pname, double[] @params) => Interface.glGetDoublev(pname, @params.Ptr());
    public static Enums.Error GetError() => Interface.glGetError();
    public static void GetFloatv(Enums.PName pname, float[] @params) => Interface.glGetFloatv(pname, @params.Ptr());
    public static void GetIntegerv(Enums.PName pname, int[] @params) => Interface.glGetIntegerv(pname, @params.Ptr());
    public static void GetLightfv(Enums.Light light, Enums.LightN pname, float[] @params) => Interface.glGetLightfv(light, pname, @params.Ptr());
    public static void GetLightiv(Enums.Light light, Enums.LightN pname, int[] @params) => Interface.glGetLightiv(light, pname, @params.Ptr());
    public static void GetMapdv(Enums.MapTarget target, Enums.Query query, double[] v) => Interface.glGetMapdv(target, query, v.Ptr());
    public static void GetMapfv(Enums.MapTarget target, Enums.Query query, float[] v) => Interface.glGetMapfv(target, query, v.Ptr());
    public static void GetMapiv(Enums.MapTarget target, Enums.Query query, int[] v) => Interface.glGetMapiv(target, query, v.Ptr());
    public static void GetMaterialfv(Enums.Side face, Enums.MaterialParam pname, float[] @params) => Interface.glGetMaterialfv(face, pname, @params.Ptr());
    public static void GetMaterialiv(Enums.Side face, Enums.MaterialParam pname, int[] @params) => Interface.glGetMaterialiv(face, pname, @params.Ptr());
    public static void GetPixelMapfv(Enums.Map map, float[] values) => Interface.glGetPixelMapfv(map, values.Ptr());
    public static void GetPixelMapuiv(Enums.Map map, uint[] values) => Interface.glGetPixelMapuiv(map, values.Ptr());
    public static void GetPixelMapusv(Enums.Map map, ushort[] values) => Interface.glGetPixelMapusv(map, values.Ptr());
    public static void GetPointerv(Enums.PNamePtr pname, void** @params) => Interface.glGetPointerv(pname, @params);
    public static void GetPolygonStipple(byte[] mask) => Interface.glGetPolygonStipple(mask.Ptr());
    public static byte* GetString(Enums.StringName name) => Interface.glGetString(name);
    public static void GetTexEnvfv(Enums.TexEnvN pname, float[] @params) => Interface.glGetTexEnvfv(Enums.TextureEnv, pname, @params.Ptr());
    public static void GetTexEnviv(Enums.TexEnvN pname, int[] @params) => Interface.glGetTexEnviv(Enums.TextureEnv, pname, @params.Ptr());
    public static void GetTexGendv(Enums.Coords coord, Enums.TexGenN pname, double[] @params) => Interface.glGetTexGendv(coord, pname, @params.Ptr());
    public static void GetTexGenfv(Enums.Coords coord, Enums.TexGenN pname, float[] @params) => Interface.glGetTexGenfv(coord, pname, @params.Ptr());
    public static void GetTexGeniv(Enums.Coords coord, Enums.TexGenN pname, int[] @params) => Interface.glGetTexGeniv(coord, pname, @params.Ptr());
    public static void GetTexImage(Enums.TexTarget target, int level, Enums.Image format, Enums.BType type, void* pixels) => Interface.glGetTexImage(target, level, format, type, pixels);
    public static void GetTexLevelParameterfv(Enums.TexPTarget target, int level, Enums.TexN pname, float[] @params) => Interface.glGetTexLevelParameterfv(target, level, pname, @params.Ptr());
    public static void GetTexLevelParameteriv(Enums.TexPTarget target, int level, Enums.TexN pname, int[] @params) => Interface.glGetTexLevelParameteriv(target, level, pname, @params.Ptr());
    public static void GetTexParameterfv(Enums.TexTarget target, Enums.TexNV pname, float[] @params) => Interface.glGetTexParameterfv(target, pname, @params.Ptr());
    public static void GetTexParameteriv(Enums.TexTarget target, Enums.TexNV pname, int[] @params) => Interface.glGetTexParameteriv(target, pname, @params.Ptr());
    public static void Hint(Enums.Hint target, Enums.Calc mode) => Interface.glHint(target, mode);
    public static void IndexMask(uint mask) => Interface.glIndexMask(mask);
    public static void IndexPointer(Enums.TexType type, int stride, void* pointer) => Interface.glIndexPointer(type, stride, pointer);
    public static void Indexd(double c) => Interface.glIndexd(c);
    public static void Indexdv(double[] c) => Interface.glIndexdv(c.Ptr());
    public static void Indexf(float c) => Interface.glIndexf(c);
    public static void Indexfv(float[] c) => Interface.glIndexfv(c.Ptr());
    public static void Indexi(int c) => Interface.glIndexi(c);
    public static void Indexiv(int[] c) => Interface.glIndexiv(c.Ptr());
    public static void Indexs(short c) => Interface.glIndexs(c);
    public static void Indexsv(short[] c) => Interface.glIndexsv(c.Ptr());
    public static void Indexub(byte c) => Interface.glIndexub(c);
    public static void Indexubv(byte[] c) => Interface.glIndexubv(c.Ptr());
    public static void InitNames() => Interface.glInitNames();
    public static void InterleavedArrays(Enums.ArrayFormat format, int stride, void* pointer) => Interface.glInterleavedArrays(format, stride, pointer);
    public static byte IsEnabled(Enums.Cap cap) => Interface.glIsEnabled(cap);
    public static byte IsList(uint list) => Interface.glIsList(list);
    public static byte IsTexture(uint texture) => Interface.glIsTexture(texture);
    public static void LightModelf(Enums.LightModel pname, float param) => Interface.glLightModelf(pname, param);
    public static void LightModelfv(Enums.LightModel pname, float[] @params) => Interface.glLightModelfv(pname, @params.Ptr());
    public static void LightModeli(Enums.LightModel pname, int param) => Interface.glLightModeli(pname, param);
    public static void LightModeliv(Enums.LightModel pname, int[] @params) => Interface.glLightModeliv(pname, @params.Ptr());
    public static void Lightf(Enums.Light light, Enums.LightN pname, float param) => Interface.glLightf(light, pname, param);
    public static void Lightfv(Enums.Light light, Enums.LightN pname, float[] @params) => Interface.glLightfv(light, pname, @params.Ptr());
    public static void Lighti(Enums.Light light, Enums.LightN pname, int param) => Interface.glLighti(light, pname, param);
    public static void Lightiv(Enums.Light light, Enums.LightN pname, int[] @params) => Interface.glLightiv(light, pname, @params.Ptr());
    public static void LineStipple(int factor, ushort pattern) => Interface.glLineStipple(factor, pattern);
    public static void LineWidth(float width) => Interface.glLineWidth(width);
    public static void ListBase(uint @base) => Interface.glListBase(@base);
    public static void LoadIdentity() => Interface.glLoadIdentity();
    public static void LoadMatrixd(double[] m) => Interface.glLoadMatrixd(m.Ptr());
    public static void LoadMatrixf(float[] m) => Interface.glLoadMatrixf(m.Ptr());
    public static void LoadName(uint name) => Interface.glLoadName(name);
    public static void LogicOp(Enums.OpCode opcode) => Interface.glLogicOp(opcode);
    public static void Map1d(Enums.Map1Target target, double u1, double u2, int stride, int order, double[] points) => Interface.glMap1d(target, u1, u2, stride, order, points.Ptr());
    public static void Map1f(Enums.Map1Target target, float u1, float u2, int stride, int order, float[] points) => Interface.glMap1f(target, u1, u2, stride, order, points.Ptr());
    public static void Map2d(Enums.Map1Target target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double[] points) => Interface.glMap2d(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points.Ptr());
    public static void Map2f(Enums.Map1Target target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float[] points) => Interface.glMap2f(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points.Ptr());
    public static void MapGrid1d(int un, double u1, double u2) => Interface.glMapGrid1d(un, u1, u2);
    public static void MapGrid1f(int un, float u1, float u2) => Interface.glMapGrid1f(un, u1, u2);
    public static void MapGrid2d(int un, double u1, double u2, int vn, double v1, double v2) => Interface.glMapGrid2d(un, u1, u2, vn, v1, v2);
    public static void MapGrid2f(int un, float u1, float u2, int vn, float v1, float v2) => Interface.glMapGrid2f(un, u1, u2, vn, v1, v2);
    public static void Materialf(Enums.Side face, float param) => Interface.glMaterialf(face, Enums.Shininess, param);
    public static void Materialfv(Enums.Side face, Enums.MaterialParam pname, float[] @params) => Interface.glMaterialfv(face, pname, @params.Ptr());
    public static void Materiali(Enums.Side face, Enums.MaterialParam pname, int param) => Interface.glMateriali(face, pname, param);
    public static void Materialiv(Enums.Side face, Enums.MaterialParam pname, int[] @params) => Interface.glMaterialiv(face, pname, @params.Ptr());
    public static void MatrixMode(Enums.Matrix mode) => Interface.glMatrixMode(mode);
    public static void MultMatrixd(double[] m) => Interface.glMultMatrixd(m.Ptr());
    public static void MultMatrixf(float[] m) => Interface.glMultMatrixf(m.Ptr());
    public static void NewList(uint list, Enums.Compile mode) => Interface.glNewList(list, mode);
    public static void Normal3b(sbyte nx, sbyte ny, sbyte nz) => Interface.glNormal3b(nx, ny, nz);
    public static void Normal3bv(sbyte[] v) => Interface.glNormal3bv(v.Ptr());
    public static void Normal3d(double nx, double ny, double nz) => Interface.glNormal3d(nx, ny, nz);
    public static void Normal3dv(double[] v) => Interface.glNormal3dv(v.Ptr());
    public static void Normal3f(float nx, float ny, float nz) => Interface.glNormal3f(nx, ny, nz);
    public static void Normal3fv(float[] v) => Interface.glNormal3fv(v.Ptr());
    public static void Normal3i(int nx, int ny, int nz) => Interface.glNormal3i(nx, ny, nz);
    public static void Normal3iv(int[] v) => Interface.glNormal3iv(v.Ptr());
    public static void Normal3s(short nx, short ny, short nz) => Interface.glNormal3s(nx, ny, nz);
    public static void Normal3sv(short[] v) => Interface.glNormal3sv(v.Ptr());
    public static void NormalPointer(Enums.PtrType type, int stride, void* pointer) => Interface.glNormalPointer(type, stride, pointer);
    public static void Ortho(double left, double right, double bottom, double top, double zNear, double zFar) => Interface.glOrtho(left, right, bottom, top, zNear, zFar);
    public static void PassThrough(float token) => Interface.glPassThrough(token);
    public static void PixelMapfv(Enums.Map map, int mapsize, float[] values) => Interface.glPixelMapfv(map, mapsize, values.Ptr());
    public static void PixelMapuiv(Enums.Map map, int mapsize, uint[] values) => Interface.glPixelMapuiv(map, mapsize, values.Ptr());
    public static void PixelMapusv(Enums.Map map, int mapsize, ushort[] values) => Interface.glPixelMapusv(map, mapsize, values.Ptr());
    public static void PixelStoref(Enums.StoreN pname, float param) => Interface.glPixelStoref(pname, param);
    public static void PixelStorei(Enums.StoreN pname, int param) => Interface.glPixelStorei(pname, param);
    public static void PixelTransferf(Enums.TransferN pname, float param) => Interface.glPixelTransferf(pname, param);
    public static void PixelTransferi(Enums.TransferN pname, int param) => Interface.glPixelTransferi(pname, param);
    public static void PixelZoom(float xfactor, float yfactor) => Interface.glPixelZoom(xfactor, yfactor);
    public static void PointSize(float size) => Interface.glPointSize(size);
    public static void PolygonMode(Enums.MaterialFace face, Enums.Mesh mode) => Interface.glPolygonMode(face, mode);
    public static void PolygonOffset(float factor, float units) => Interface.glPolygonOffset(factor, units);
    public static void PolygonStipple(byte[] mask) => Interface.glPolygonStipple(mask.Ptr());
    public static void PopAttrib() => Interface.glPopAttrib();
    public static void PopClientAttrib() => Interface.glPopClientAttrib();
    public static void PopMatrix() => Interface.glPopMatrix();
    public static void PopName() => Interface.glPopName();
    public static void PrioritizeTextures(int n, uint[] textures, float[] priorities) => Interface.glPrioritizeTextures(n, textures.Ptr(), priorities.Ptr());
    public static void PushAttrib(uint mask) => Interface.glPushAttrib(mask);
    public static void PushClientAttrib(uint mask) => Interface.glPushClientAttrib(mask);
    public static void PushMatrix() => Interface.glPushMatrix();
    public static void PushName(uint name) => Interface.glPushName(name);
    public static void RasterPos2d(double x, double y) => Interface.glRasterPos2d(x, y);
    public static void RasterPos2dv(double[] v) => Interface.glRasterPos2dv(v.Ptr());
    public static void RasterPos2f(float x, float y) => Interface.glRasterPos2f(x, y);
    public static void RasterPos2fv(float[] v) => Interface.glRasterPos2fv(v.Ptr());
    public static void RasterPos2i(int x, int y) => Interface.glRasterPos2i(x, y);
    public static void RasterPos2iv(int[] v) => Interface.glRasterPos2iv(v.Ptr());
    public static void RasterPos2s(short x, short y) => Interface.glRasterPos2s(x, y);
    public static void RasterPos2sv(short[] v) => Interface.glRasterPos2sv(v.Ptr());
    public static void RasterPos3d(double x, double y, double z) => Interface.glRasterPos3d(x, y, z);
    public static void RasterPos3dv(double[] v) => Interface.glRasterPos3dv(v.Ptr());
    public static void RasterPos3f(float x, float y, float z) => Interface.glRasterPos3f(x, y, z);
    public static void RasterPos3fv(float[] v) => Interface.glRasterPos3fv(v.Ptr());
    public static void RasterPos3i(int x, int y, int z) => Interface.glRasterPos3i(x, y, z);
    public static void RasterPos3iv(int[] v) => Interface.glRasterPos3iv(v.Ptr());
    public static void RasterPos3s(short x, short y, short z) => Interface.glRasterPos3s(x, y, z);
    public static void RasterPos3sv(short[] v) => Interface.glRasterPos3sv(v.Ptr());
    public static void RasterPos4d(double x, double y, double z, double w) => Interface.glRasterPos4d(x, y, z, w);
    public static void RasterPos4dv(double[] v) => Interface.glRasterPos4dv(v.Ptr());
    public static void RasterPos4f(float x, float y, float z, float w) => Interface.glRasterPos4f(x, y, z, w);
    public static void RasterPos4fv(float[] v) => Interface.glRasterPos4fv(v.Ptr());
    public static void RasterPos4i(int x, int y, int z, int w) => Interface.glRasterPos4i(x, y, z, w);
    public static void RasterPos4iv(int[] v) => Interface.glRasterPos4iv(v.Ptr());
    public static void RasterPos4s(short x, short y, short z, short w) => Interface.glRasterPos4s(x, y, z, w);
    public static void RasterPos4sv(short[] v) => Interface.glRasterPos4sv(v.Ptr());
    public static void ReadBuffer(Enums.Buf mode) => Interface.glReadBuffer(mode);
    public static void ReadPixels(int x, int y, int width, int height, Enums.Image format, Enums.ReadType type, void* pixels) => Interface.glReadPixels(x, y, width, height, format, type, pixels);
    public static void Rectd(double x1, double y1, double x2, double y2) => Interface.glRectd(x1, y1, x2, y2);
    public static void Rectdv(double[] v1, double[] v2) => Interface.glRectdv(v1.Ptr(), v2.Ptr());
    public static void Rectf(float x1, float y1, float x2, float y2) => Interface.glRectf(x1, y1, x2, y2);
    public static void Rectfv(float[] v1, float[] v2) => Interface.glRectfv(v1.Ptr(), v2.Ptr());
    public static void Recti(int x1, int y1, int x2, int y2) => Interface.glRecti(x1, y1, x2, y2);
    public static void Rectiv(int[] v1, int[] v2) => Interface.glRectiv(v1.Ptr(), v2.Ptr());
    public static void Rects(short x1, short y1, short x2, short y2) => Interface.glRects(x1, y1, x2, y2);
    public static void Rectsv(short[] v1, short[] v2) => Interface.glRectsv(v1.Ptr(), v2.Ptr());
    public static int RenderMode(Enums.Render mode) => Interface.glRenderMode(mode);
    public static void Rotated(double angle, double x, double y, double z) => Interface.glRotated(angle, x, y, z);
    public static void Rotatef(float angle, float x, float y, float z) => Interface.glRotatef(angle, x, y, z);
    public static void Scaled(double x, double y, double z) => Interface.glScaled(x, y, z);
    public static void Scalef(float x, float y, float z) => Interface.glScalef(x, y, z);
    public static void Scissor(int x, int y, int width, int height) => Interface.glScissor(x, y, width, height);
    public static void SelectBuffer(int size, uint[] buffer) => Interface.glSelectBuffer(size, buffer.Ptr());
    public static void ShadeModel(Enums.Fill mode) => Interface.glShadeModel(mode);
    public static void StencilFunc(Enums.Func func, int @ref, uint mask) => Interface.glStencilFunc(func, @ref, mask);
    public static void StencilMask(uint mask) => Interface.glStencilMask(mask);
    public static void StencilOp(Enums.Fail fail, Enums.Fail zfail, Enums.Fail zpass) => Interface.glStencilOp(fail, zfail, zpass);
    public static void TexCoord1d(double s) => Interface.glTexCoord1d(s);
    public static void TexCoord1dv(double[] v) => Interface.glTexCoord1dv(v.Ptr());
    public static void TexCoord1f(float s) => Interface.glTexCoord1f(s);
    public static void TexCoord1fv(float[] v) => Interface.glTexCoord1fv(v.Ptr());
    public static void TexCoord1i(int s) => Interface.glTexCoord1i(s);
    public static void TexCoord1iv(int[] v) => Interface.glTexCoord1iv(v.Ptr());
    public static void TexCoord1s(short s) => Interface.glTexCoord1s(s);
    public static void TexCoord1sv(short[] v) => Interface.glTexCoord1sv(v.Ptr());
    public static void TexCoord2d(double s, double t) => Interface.glTexCoord2d(s, t);
    public static void TexCoord2dv(double[] v) => Interface.glTexCoord2dv(v.Ptr());
    public static void TexCoord2f(float s, float t) => Interface.glTexCoord2f(s, t);
    public static void TexCoord2fv(float[] v) => Interface.glTexCoord2fv(v.Ptr());
    public static void TexCoord2i(int s, int t) => Interface.glTexCoord2i(s, t);
    public static void TexCoord2iv(int[] v) => Interface.glTexCoord2iv(v.Ptr());
    public static void TexCoord2s(short s, short t) => Interface.glTexCoord2s(s, t);
    public static void TexCoord2sv(short[] v) => Interface.glTexCoord2sv(v.Ptr());
    public static void TexCoord3d(double s, double t, double r) => Interface.glTexCoord3d(s, t, r);
    public static void TexCoord3dv(double[] v) => Interface.glTexCoord3dv(v.Ptr());
    public static void TexCoord3f(float s, float t, float r) => Interface.glTexCoord3f(s, t, r);
    public static void TexCoord3fv(float[] v) => Interface.glTexCoord3fv(v.Ptr());
    public static void TexCoord3i(int s, int t, int r) => Interface.glTexCoord3i(s, t, r);
    public static void TexCoord3iv(int[] v) => Interface.glTexCoord3iv(v.Ptr());
    public static void TexCoord3s(short s, short t, short r) => Interface.glTexCoord3s(s, t, r);
    public static void TexCoord3sv(short[] v) => Interface.glTexCoord3sv(v.Ptr());
    public static void TexCoord4d(double s, double t, double r, double q) => Interface.glTexCoord4d(s, t, r, q);
    public static void TexCoord4dv(double[] v) => Interface.glTexCoord4dv(v.Ptr());
    public static void TexCoord4f(float s, float t, float r, float q) => Interface.glTexCoord4f(s, t, r, q);
    public static void TexCoord4fv(float[] v) => Interface.glTexCoord4fv(v.Ptr());
    public static void TexCoord4i(int s, int t, int r, int q) => Interface.glTexCoord4i(s, t, r, q);
    public static void TexCoord4iv(int[] v) => Interface.glTexCoord4iv(v.Ptr());
    public static void TexCoord4s(short s, short t, short r, short q) => Interface.glTexCoord4s(s, t, r, q);
    public static void TexCoord4sv(short[] v) => Interface.glTexCoord4sv(v.Ptr());
    public static void TexCoordPointer(int size, Enums.TexType type, int stride, void* pointer) => Interface.glTexCoordPointer(size, type, stride, pointer);
    public static void TexEnvf(Enums.TexEnvN pname, float param) => Interface.glTexEnvf(Enums.TextureEnv, pname, param);
    public static void TexEnvfv(Enums.TexEnvN pname, float[] @params) => Interface.glTexEnvfv(Enums.TextureEnv, pname, @params.Ptr());
    public static void TexEnvi(Enums.TexEnvN pname, int param) => Interface.glTexEnvi(Enums.TextureEnv, pname, param);
    public static void TexEnviv(Enums.TexEnvN pname, int[] @params) => Interface.glTexEnviv(Enums.TextureEnv, pname, @params.Ptr());
    public static void TexGend(Enums.Coords coord, Enums.TexGen pname, double param) => Interface.glTexGend(coord, pname, param);
    public static void TexGendv(Enums.Coords coord, Enums.TexGen pname, double[] @params) => Interface.glTexGendv(coord, pname, @params.Ptr());
    public static void TexGenf(Enums.Coords coord, Enums.TexGen pname, float param) => Interface.glTexGenf(coord, pname, param);
    public static void TexGenfv(Enums.Coords coord, Enums.TexGen pname, float[] @params) => Interface.glTexGenfv(coord, pname, @params.Ptr());
    public static void TexGeni(Enums.Coords coord, Enums.TexGen pname, int param) => Interface.glTexGeni(coord, pname, param);
    public static void TexGeniv(Enums.Coords coord, Enums.TexGen pname, int[] @params) => Interface.glTexGeniv(coord, pname, @params.Ptr());
    public static void TexImage1D(int level, int internalformat, int width, int border, Enums.ImageFormat format, Enums.ImageType type, void* pixels) => Interface.glTexImage1D((int)Enums.TexTarget.Texture1D, level, internalformat, width, border, format, type, pixels);
    public static void TexImage2D(int level, int internalformat, int width, int height, int border, Enums.ImageFormat format, Enums.ImageType type, void* pixels) => Interface.glTexImage2D((int)Enums.TexTarget.Texture2D, level, internalformat, width, height, border, format, type, pixels);
    public static void TexParameterf(Enums.TexTarget target, Enums.TexNV2 pname, float param) => Interface.glTexParameterf(target, pname, param);
    public static void TexParameterfv(Enums.TexTarget target, Enums.TexNV2 pname, float[] @params) => Interface.glTexParameterfv(target, pname, @params.Ptr());
    public static void TexParameteri(Enums.TexTarget target, Enums.TexNV2 pname, int param) => Interface.glTexParameteri(target, pname, param);
    public static void TexParameteriv(Enums.TexTarget target, Enums.TexNV2 pname, int[] @params) => Interface.glTexParameteriv(target, pname, @params.Ptr());
    public static void TexSubImage1D(int level, int xoffset, int width, Enums.ImageFormat format, Enums.ImageType type, void* pixels) => Interface.glTexSubImage1D((int)Enums.TexTarget.Texture1D, level, xoffset, width, format, type, pixels);
    public static void TexSubImage2D(int level, int xoffset, int yoffset, int width, int height, Enums.ImageFormat format, Enums.ImageType type, void* pixels) => Interface.glTexSubImage2D((int)Enums.TexTarget.Texture2D, level, xoffset, yoffset, width, height, format, type, pixels);
    public static void Translated(double x, double y, double z) => Interface.glTranslated(x, y, z);
    public static void Translatef(float x, float y, float z) => Interface.glTranslatef(x, y, z);
    public static void Vertex2d(double x, double y) => Interface.glVertex2d(x, y);
    public static void Vertex2dv(double[] v) => Interface.glVertex2dv(v.Ptr());
    public static void Vertex2f(float x, float y) => Interface.glVertex2f(x, y);
    public static void Vertex2fv(float[] v) => Interface.glVertex2fv(v.Ptr());
    public static void Vertex2i(int x, int y) => Interface.glVertex2i(x, y);
    public static void Vertex2iv(int[] v) => Interface.glVertex2iv(v.Ptr());
    public static void Vertex2s(short x, short y) => Interface.glVertex2s(x, y);
    public static void Vertex2sv(short[] v) => Interface.glVertex2sv(v.Ptr());
    public static void Vertex3d(double x, double y, double z) => Interface.glVertex3d(x, y, z);
    public static void Vertex3dv(double[] v) => Interface.glVertex3dv(v.Ptr());
    public static void Vertex3f(float x, float y, float z) => Interface.glVertex3f(x, y, z);
    public static void Vertex3fv(float[] v) => Interface.glVertex3fv(v.Ptr());
    public static void Vertex3i(int x, int y, int z) => Interface.glVertex3i(x, y, z);
    public static void Vertex3iv(int[] v) => Interface.glVertex3iv(v.Ptr());
    public static void Vertex3s(short x, short y, short z) => Interface.glVertex3s(x, y, z);
    public static void Vertex3sv(short[] v) => Interface.glVertex3sv(v.Ptr());
    public static void Vertex4d(double x, double y, double z, double w) => Interface.glVertex4d(x, y, z, w);
    public static void Vertex4dv(double[] v) => Interface.glVertex4dv(v.Ptr());
    public static void Vertex4f(float x, float y, float z, float w) => Interface.glVertex4f(x, y, z, w);
    public static void Vertex4fv(float[] v) => Interface.glVertex4fv(v.Ptr());
    public static void Vertex4i(int x, int y, int z, int w) => Interface.glVertex4i(x, y, z, w);
    public static void Vertex4iv(int[] v) => Interface.glVertex4iv(v.Ptr());
    public static void Vertex4s(short x, short y, short z, short w) => Interface.glVertex4s(x, y, z, w);
    public static void Vertex4sv(short[] v) => Interface.glVertex4sv(v.Ptr());
    public static void VertexPointer(int size, Enums.TexType type, int stride, void* pointer) => Interface.glVertexPointer(size, type, stride, pointer);
    public static void Viewport(int x, int y, int width, int height) => Interface.glViewport(x, y, width, height);

    private static T* Ptr<T>(this T obj) where T : unmanaged
    {
        TypedReference reference = __makeref(obj);
        IntPtr addr = (IntPtr)(&reference);
        return (T*)addr.ToPointer();
    }

    private static T* Ptr<T>(this T[] obj) where T : unmanaged
    {
        fixed (T* ptr = obj)
            return ptr;
    }
}